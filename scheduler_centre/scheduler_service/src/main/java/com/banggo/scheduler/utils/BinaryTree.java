package com.banggo.scheduler.utils;

public class BinaryTree<E> {
	/*private Node<E> root;

	private static class Node<E> {
		Node<E> left;
		Node<E> right;
		E data;

		Node(E newData) {
			left = null;
			right = null;
			data = newData;
		}
	}

	public void emptyTree() {
		root = null;
	}

	

	public void insert(E data) {
		root = insert(root, data);
	}

	private Node insert(Node<E> node, E data) {
		if (node == null) {
			node = new Node(data);
		} else {
			if (data <= node.data) {
				node.left = insert(node.left, data);
			} else {
				node.right = insert(node.right, data);
			}
		}

		return (node);
	}

	public int size() {
		return (size(root));
	}

	private int size(Node node) {
		if (node == null)
			return (0);
		else {
			return (size(node.left) + 1 + size(node.right));
		}
	}

	public int maxDepth() {
		return (maxDepth(root));
	}

	private int maxDepth(Node<E> node) {
		if (node == null) {
			return (0);
		} else {
			int lDepth = maxDepth(node.left);
			int rDepth = maxDepth(node.right);

			// use the larger + 1
			return (Math.max(lDepth, rDepth) + 1);
		}
	}

	public void printTree() {
		printTree(root);
		System.out.println();
	}

	private void printTree(Node<E> node) {
		if (node == null)
			return;

		// left, node itself, right
		printTree(node.left);
		System.out.print(node.data + "  ");
		printTree(node.right);
	}

	public void printPostorder() {
		printPostorder(root);
		System.out.println();
	}

	public void printPostorder(Node<E> node) {
		if (node == null)
			return;

		// first recur on both subtrees
		printPostorder(node.left);
		printPostorder(node.right);

		// then deal with the node
		System.out.print(node.data + "  ");
	}*/
}
